#include <Servo.h>
#include <NewPing.h>        


const int LeftMotorForward2 = 9;
const int LeftMotorBackward2 = 10;
const int RightMotorForward2 = 11;
const int RightMotorBackward2 = 12;

//sensor pins
#define trig_pinf A1 //analog input 1
#define echo_pinf A2 //analog input 2
#define trig_pinr A3
#define echo_pinr A4
#define trig_pinl A5
#define echo_pinl A6

//Setting up the maximum distance
#define maximum_distance 200
boolean goesForward = false;
int distance = 100;

NewPing sonar(trig_pinf, echo_pinf, maximum_distance); //sensor function

Servo servo_motor;

int angle = 0;

//PID code for the car adjustment
/*#include <PID_v1.h>

#define LEFT_INPUT 1 //left encoder 
#define RIGHT_INPUT 2 //right encoder 
#define LEFT_OUTPUT_A 40 //left motor A
#define LEFT_OUTPUT_B 41 //left motor B
#define RIGHT_OUTPUT_A 42 //right motor A
#define RIGHT_OUTPUT_B 43 //right motor B

double LeftInput, RightInput, LeftOutput, RightOutput;
double Kp = 0, Ki = 0, Kd = 0;*/


void setup(){

  /*LeftInput = analogRead(LEFT_INPUT); //read left encoder
  RightInput = analogRead(RIGHT_INPUT); //read right encoder*/

//Setting up the motor function

  pinMode(RightMotorForward2, OUTPUT);
  pinMode(LeftMotorForward2, OUTPUT);
  pinMode(LeftMotorBackward2, OUTPUT);
  pinMode(RightMotorBackward2, OUTPUT);
  
myservo.attach(5);
  delay(2000);
  distance = readPingf();
  delay(100);
  distance = readPingf();
  delay(100);
  distance = readPingf();
  delay(100);
  distance = readPingf();
  delay(100);
}

void loop(){

  int distanceRight = 0;
  int distanceLeft = 0;
  delay(50);

  if (distance <= 25){ //If the car approach an obstacle within 25 cm
    moveStop(); //Stop
    delay(300);
    moveBackward(); //Go backward
    delay(400);
    moveStop(); //Stop
    delay(300);
    distanceRight = lookRight(); //Look on the right side
    delay(300);
    distanceLeft = lookLeft(); // Look on the left side
    delay(300);

    if (distance >= distanceLeft){ //If there is obstacle on the left side, turn right
      turnRight();
      moveStop();
    }
    else{
      turnLeft(); //Other than that, turn left
      moveStop();
    }
  }
  else{
    moveForward(); //Other than that, go forward
  }
    distance = readPingf(); //base upon ultrasonic sensor
}

int readPingf(){ //Variable for reading from ultrasonic sensor
 long dur;
 digitalWrite(trig_pinf, LOW);
 delayMicroseconds(5); // delays are required for a succesful sensor operation.
 digitalWrite(trig_pinf, HIGH);
 delayMicroseconds(10); //this delay is required as well!
 digitalWrite(trig_pinf, LOW);
 dur = pulseIn(echo_pinf, HIGH);
 return (dur/58);// convert the distance to centimeters.
}


int readPingr(){ //Variable for reading from ultrasonic sensor

long dur;
 digitalWrite(trig_pinr, LOW);
 delayMicroseconds(5); // delays are required for a succesful sensor operation.
 digitalWrite(trig_pinr, HIGH);
 delayMicroseconds(10); //this delay is required as well!
 digitalWrite(trig_pinr, LOW);
 dur = pulseIn(echo_pinr, HIGH);
 return (dur/58);// convert the distance to centimeters.
}

int readPingl(){ //Variable for reading from ultrasonic sensor
long dur;
 digitalWrite(trig_pinl, LOW);
 delayMicroseconds(5); // delays are required for a succesful sensor operation.
 digitalWrite(trig_pinl, HIGH);
 delayMicroseconds(10); //this delay is required as well!
 digitalWrite(trig_pinl, LOW);
 dur = pulseIn(echo_pinl, HIGH);
 return (dur/58);// convert the distance to centimeters.
}



int lookRight(){  // Variable for looking on the right side

  delay(500);
  int distance = readPingr();
  delay(100);

  return distance;
}

int lookLeft(){ // Variable for looking on the left side

  delay(500);
  int distance = readPingl();
  delay(100);
  return distance;
  delay(100);
}


void moveBackward(){ //Function for each wheel when moving backward

  goesForward=false;


  digitalWrite(LeftMotorBackward2, HIGH);
  digitalWrite(RightMotorBackward2, HIGH);
  digitalWrite(LeftMotorForward2, LOW);
  digitalWrite(RightMotorForward2, LOW);
  
}

void moveForward(){ //Function for each wheel when moving forward

  if(!goesForward){

    goesForward=true;
    
    digitalWrite(LeftMotorForward2, HIGH);
    digitalWrite(RightMotorForward2, HIGH);
    digitalWrite(LeftMotorBackward2, LOW);
    digitalWrite(RightMotorBackward2, LOW); 
  }
}

void turnLeft(){ //Function for each wheel when turning left

  servo_motor.write(45);
  
  digitalWrite(LeftMotorBackward2, HIGH);
  digitalWrite(RightMotorForward2, HIGH);
  digitalWrite(LeftMotorForward2, HIGH);
  digitalWrite(RightMotorBackward2, HIGH);

  delay(500);
  
  
  digitalWrite(LeftMotorForward2, HIGH);
  digitalWrite(RightMotorForward2, HIGH);
  digitalWrite(LeftMotorBackward2, HIGH);
  digitalWrite(RightMotorForward2, HIGH);
  }
  
  void turnRight(){ //Function for each wheel when turning right


  digitalWrite(LeftMotorForward2, HIGH);
  digitalWrite(RightMotorBackward2, HIGH);
  digitalWrite(LeftMotorBackward2, LOW);
  digitalWrite(RightMotorForward2, LOW);
  
  delay(500);
  
  digitalWrite(LeftMotorForward2, HIGH);
  digitalWrite(RightMotorForward2, HIGH);
  digitalWrite(LeftMotorBackward2, LOW);
  digitalWrite(RightMotorBackward2, LOW);

}
  
  void moveStop(){ //Function for each wheel when stop
  

  digitalWrite(RightMotorForward2, LOW);
  digitalWrite(LeftMotorForward2, LOW);
  digitalWrite(RightMotorBackward2, LOW);
  digitalWrite(LeftMotorBackward2, LOW);
}

//PID Code

/*void PIDstraight() {
  //if left is greater than right, we reduce it to the speed of the right
  while (LeftInput > RightInput) {
    PID myPID(&LeftInput, &LeftOutput, &RightInput, Kp, Ki, Kd, DIRECT);
    myPID.SetMode(AUTOMATIC); //intialize PID
    myPID.Compute();
    analogWrite(LEFT_OUTPUT_A, LeftOutput);
    analogWrite(LEFT_OUTPUT_B, LeftOutput);
  }

  //if right is greater than left, we reduce it to the speed of the left
  while (LeftInput < RightInput) {
    PID myPID(&RightInput, &RightOutput, &LeftInput, Kp, Ki, Kd, DIRECT);
    myPID.SetMode(AUTOMATIC); //intialize PID
    myPID.Compute();
    analogWrite(RIGHT_OUTPUT_A, RightOutput);
    analogWrite(RIGHT_OUTPUT_B, RightOutput);
  }
}

//Floodfill Code
//int (distance <= 25) = X;
//(x,y) is the original coordinate 
//(dest_x, dest_y) is the destination coordinates
//DFS(int x,int y, int dest_x, int dest_y); 
int x;
int y;
int dest_x;
int dest_y;
//{

void DFS(int x, int y, int dest_x, int dest_y){
  if(x == dest_x & y == dest_y) //If the robot is going to sastify the coordinates of the destination, then move 
    {return true;
    }
  
      if(x >= dest_x || y >= dest_y) //If the robot only sastify one of the coordinates, then stop
          {return false;
          }
  
      if(x < 0 || y < 0) //If the robot go outside of the matrix, then stop
          {return false;
          }
  
    if(x & y == distance <= 25) //"X" is the obstacle and if the robot move there, then stop
          {return false;
          }

      if (DFS(x+1 == dest_x & y == dest_y) == True); //move to the right to meet the destination
          {return true;
          }
    if (DFS(x-1 == dest_x & y == dest_y) == True); //move to the left to meet the destination
          {return true;
          }
      if (DFS(x == dest_x & y+1 == dest_y) == True); //move down to meet the destination
          {return true;
          }
    if (DFS(x == dest_x & y-1 == dest_y) == True);
          {return true;
          }
  else {
  return false;
  }
}

//End of floodfill code*/
