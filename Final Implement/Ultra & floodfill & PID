#include <Servo.h>          
#include <NewPing.h>        

//L298N motor control pins
const int LeftMotorForward1 = 6;
const int LeftMotorBackward1 = 7;
const int RightMotorForward1 = 5;
const int RightMotorBackward1 = 4;
const int LeftMotorForward2 = 8;
const int LeftMotorBackward2 = 9;
const int RightMotorForward2 = 10;
const int RightMotorBackward2 = 11;

//sensor pins
#define trig_pin A1 //analog input 1
#define echo_pin A2 //analog input 2

//Setting up the maximum distance
#define maximum_distance 200
boolean goesForward = false;
int distance = 100;

NewPing sonar(trig_pin, echo_pin, maximum_distance); //sensor function
Servo servo_motor; 


//PID code for the car adjustment
#include <PID_v1.h>

#define LEFT_INPUT 1 //left encoder 
#define RIGHT_INPUT 2 //right encoder 
#define LEFT_OUTPUT_A 40 //left motor A
#define LEFT_OUTPUT_B 41 //left motor B
#define RIGHT_OUTPUT_A 42 //right motor A
#define RIGHT_OUTPUT_B 43 //right motor B

double LeftInput, RightInput, LeftOutput, RightOutput;
double Kp = 0, Ki = 0, Kd = 0;


void setup(){

  LeftInput = analogRead(LEFT_INPUT); //read left encoder
  RightInput = analogRead(RIGHT_INPUT); //read right encoder

//Setting up the motor function
  pinMode(RightMotorForward1, OUTPUT);
  pinMode(LeftMotorForward1, OUTPUT);
  pinMode(LeftMotorBackward1, OUTPUT);
  pinMode(RightMotorBackward1, OUTPUT);
  pinMode(RightMotorForward2, OUTPUT);
  pinMode(LeftMotorForward2, OUTPUT);
  pinMode(LeftMotorBackward2, OUTPUT);
  pinMode(RightMotorBackward2, OUTPUT);
  
  servo_motor.attach(9); //our servo pin

//Thorough run between servo and ultrasonic sensor
  servo_motor.write(115);
  delay(2000);
  distance = readPing();
  delay(100);
  distance = readPing();
  delay(100);
  distance = readPing();
  delay(100);
  distance = readPing();
  delay(100);
}

void loop(){

  int distanceRight = 0;
  int distanceLeft = 0;
  delay(50);

  if (distance <= 25){ //If the car approach an obstacle within 25 cm
    moveStop(); //Stop
    delay(300);
    moveBackward(); //Go backward
    delay(400);
    moveStop(); //Stop
    delay(300);
    distanceRight = lookRight(); //Look on the right side
    delay(300);
    distanceLeft = lookLeft(); // Look on the left side
    delay(300);

    if (distance >= distanceLeft){ //If there is obstacle on the left side, turn right
      turnRight();
      moveStop();
    }
    else{
      turnLeft(); //Other than that, turn left
      moveStop();
    }
  }
  else{
    moveForward(); //Other than that, go forward
  }
    distance = readPing(); //base upon ultrasonic sensor
}

int readPing(){ //Variable for reading from ultrasonic sensor
  delay(70);
  int cm = sonar.ping_cm();
  if (cm==0){
    cm=250;
  }
  return cm;
}



int lookRight(){  // Variable for looking on the right side
  servo_motor.write(50); //Use servo to rotate and ultrasonic sensor to detect
  delay(500);
  int distance = readPing();
  delay(100);
  servo_motor.write(115);
  return distance;
}

int lookLeft(){ // Variable for looking on the left side
  servo_motor.write(170);
  delay(500);
  int distance = readPing();
  delay(100);
  servo_motor.write(115);
  return distance;
  delay(100);
}


void moveBackward(){ //Function for each wheel when moving backward

  goesForward=false;

  digitalWrite(LeftMotorBackward1, HIGH);
  digitalWrite(RightMotorBackward1, HIGH);
  digitalWrite(LeftMotorForward1, LOW);
  digitalWrite(RightMotorForward1, LOW);
  digitalWrite(LeftMotorBackward2, HIGH);
  digitalWrite(RightMotorBackward2, HIGH);
  digitalWrite(LeftMotorForward2, LOW);
  digitalWrite(RightMotorForward2, LOW);
  
}

void moveForward(){ //Function for each wheel when moving forward

  if(!goesForward){

    goesForward=true;
    
    digitalWrite(LeftMotorForward1, HIGH);
    digitalWrite(RightMotorForward1, HIGH);
    digitalWrite(LeftMotorBackward1, LOW);
    digitalWrite(RightMotorBackward1, LOW); 
    digitalWrite(LeftMotorForward2, HIGH);
    digitalWrite(RightMotorForward2, HIGH);
    digitalWrite(LeftMotorBackward2, LOW);
    digitalWrite(RightMotorBackward2, LOW); 
  }
}

void turnLeft(){ //Function for each wheel when turning left

  digitalWrite(LeftMotorBackward1, HIGH);
  digitalWrite(RightMotorForward1, HIGH);
  digitalWrite(LeftMotorForward1, LOW);
  digitalWrite(RightMotorBackward1, LOW);
  digitalWrite(LeftMotorBackward2, HIGH);
  digitalWrite(RightMotorForward2, HIGH);
  digitalWrite(LeftMotorForward2, LOW);
  digitalWrite(RightMotorBackward2, LOW);

  delay(500);
  
  digitalWrite(LeftMotorForward1, HIGH);
  digitalWrite(RightMotorForward1, HIGH);
  digitalWrite(LeftMotorBackward1, LOW);
  digitalWrite(RightMotorForward1, LOW);
  digitalWrite(LeftMotorForward2, HIGH);
  digitalWrite(RightMotorForward2, HIGH);
  digitalWrite(LeftMotorBackward2, LOW);
  digitalWrite(RightMotorForward2, LOW);
  }
  
  void turnRight(){ //Function for each wheel when turning right

  digitalWrite(LeftMotorForward1, HIGH);
  digitalWrite(RightMotorBackward1, HIGH);
  digitalWrite(LeftMotorBackward1, LOW);
  digitalWrite(RightMotorForward1, LOW);
  digitalWrite(LeftMotorForward2, HIGH);
  digitalWrite(RightMotorBackward2, HIGH);
  digitalWrite(LeftMotorBackward2, LOW);
  digitalWrite(RightMotorForward2, LOW);
  
  delay(500);
  
  digitalWrite(LeftMotorForward1, HIGH);
  digitalWrite(RightMotorForward1, HIGH);
  digitalWrite(LeftMotorBackward1, LOW);
  digitalWrite(RightMotorBackward1, LOW);
  digitalWrite(LeftMotorForward2, HIGH);
  digitalWrite(RightMotorForward2, HIGH);
  digitalWrite(LeftMotorBackward2, LOW);
  digitalWrite(RightMotorBackward2, LOW);

}
  
  void moveStop(){ //Function for each wheel when stop
  
  digitalWrite(RightMotorForward1, LOW);
  digitalWrite(LeftMotorForward1, LOW);
  digitalWrite(RightMotorBackward1, LOW);
  digitalWrite(LeftMotorBackward1, LOW);
  digitalWrite(RightMotorForward2, LOW);
  digitalWrite(LeftMotorForward2, LOW);
  digitalWrite(RightMotorBackward2, LOW);
  digitalWrite(LeftMotorBackward2, LOW);
}

//PID Code

void PIDstraight() {
  //if left is greater than right, we reduce it to the speed of the right
  while (LeftInput > RightInput) {
    PID myPID(&LeftInput, &LeftOutput, &RightInput, Kp, Ki, Kd, DIRECT);
    myPID.SetMode(AUTOMATIC); //intialize PID
    myPID.Compute();
    analogWrite(LEFT_OUTPUT_A, LeftOutput);
    analogWrite(LEFT_OUTPUT_B, LeftOutput);
  }

  //if right is greater than left, we reduce it to the speed of the left
  while (LeftInput < RightInput) {
    PID myPID(&RightInput, &RightOutput, &LeftInput, Kp, Ki, Kd, DIRECT);
    myPID.SetMode(AUTOMATIC); //intialize PID
    myPID.Compute();
    analogWrite(RIGHT_OUTPUT_A, RightOutput);
    analogWrite(RIGHT_OUTPUT_B, RightOutput);
  }
}

//Floodfill Code
//int (distance <= 25) = X;
//(x,y) is the original coordinate 
//(dest_x, dest_y) is the destination coordinates
//DFS(int x,int y, int dest_x, int dest_y); 
int x;
int y;
int dest_x;
int dest_y;
//{

void DFS(int x, int y, int dest_x, int dest_y){
  if(x == dest_x & y == dest_y) //If the robot is going to sastify the coordinates of the destination, then move 
    {return true;
    }
  
      if(x >= dest_x || y >= dest_y) //If the robot only sastify one of the coordinates, then stop
          {return false;
          }
  
      if(x < 0 || y < 0) //If the robot go outside of the matrix, then stop
          {return false;
          }
  
    if(x & y == distance <= 25) //"X" is the obstacle and if the robot move there, then stop
          {return false;
          }

      if (DFS(x+1 == dest_x & y == dest_y) == True); //move to the right to meet the destination
          {return true;
          }
    if (DFS(x-1 == dest_x & y == dest_y) == True); //move to the left to meet the destination
          {return true;
          }
      if (DFS(x == dest_x & y+1 == dest_y) == True); //move down to meet the destination
          {return true;
          }
    if (DFS(x == dest_x & y-1 == dest_y) == True);
          {return true;
          }
  else {
  return false;
  }
}

//End of floodfill code
