#define fronthold 12  // Threshold value in front direction
#define righthold 20  // Threshold value in right direction
#define lefthold 20   // Threshold value in left direction

/*i = indices
 *j = junctions
 *f = front
 *r = right
 *t = time
 *l = left
 *a = after
 *b = before
 *o = over
 *u = u-turn
 */
 
const int t = 1050;  // Time alotted for taking 90 degress for 9V!
int tfr = 2750; // Initial Time for which it moves forward when it chooses forward over right 
int timefr;        // Dynamically set time...for which it moves forward, when it chooses forward over right
int tlbef = 440; // Time for which it moves forward before taking left turn.
int tlaf = 1150; // Time for which it moves forward after taking left turn.
int nfor =0;    // Number of times it chooses straight over right
int nlr = 0;      // Number of times it takes left turn.
bool found=false;// If its true, it indicates that the bot has reached the end
int dir[100];    // Array for storing the path of the bot.
int i=-1;        // For the indices of the dir array.
int j=0;         // Implies the number of junctions bot passed through

const int trigPinf = 3; //Front Ultrasonic Sensor
const int echoPinf = 4; 

const int trigPinr = 7; //Right Ultrasonic Sensor
const int echoPinr = 8;

const int trigPinl = 5; //Left Ultrasonic Sensor
const int echoPinl = 6;

//Booleans for recognising the walls. It will be True if the response sensor distance is less than the response threshold value.
bool fsensor;  //front Ultrasonic sensor
bool rsensor;  //right Ultrasonic sensor
bool lsensor;  //left Ultrasonic sensor

//sorts and returns the median value of a five element array.
float middleval(float arr[])
{
  for(int p=0;p<4;p++)
  {
    for(int q=0;q<4;q++)
    { 
      if(arr[q]>arr[q+1])
      {
        int temp = arr[q];
        arr[q] = arr[q+1];
        arr[q+1] = temp;
      }
    }
  }
 return arr[2]; // Median Value
}


//moves the bot in the front direction
void gofront()
{
  //Moves forward adjusting its path
  float  ldist1 = leftdist();
  float lconst = ldist1;
  while(ldist1<=5)  // Turn a little to its right
  {
    digitalWrite(9,HIGH);
    digitalWrite(10,LOW);
    digitalWrite(11,LOW);
    digitalWrite(12,LOW);

    delay(t/65);

    ldist1=leftdist();
    if(abs(lconst - ldist1)>=0.8||(ldist1>=3.6)){break;}
  }

  float rdist1 = rightdist();
  float rconst = rdist1;
  while (rdist1<=5.4) // Turn a little to its left
  { 
    digitalWrite(9,LOW);
    digitalWrite(10,LOW);
    digitalWrite(11,HIGH);
    digitalWrite(12,LOW);

    delay(t/65);

    rdist1 = rightdist();
    if(abs(rconst - rdist1)>=0.9){break;}
  }
  if(leftdist()>=7.2) //Will move little to its left if its too far from the left wall
  {
  digitalWrite(9,LOW);
  digitalWrite(10,LOW);
  digitalWrite(11,HIGH);
  digitalWrite(12,LOW);

  delay(t/30);
  }

  digitalWrite(9, HIGH);
  digitalWrite(10,LOW);
  digitalWrite(11,HIGH);
  digitalWrite(12,LOW);
  
}

//take in the distance of the front wall
float frontdist()
{
  float gapf;
  float ticktockf;

  digitalWrite(trigPinf,LOW);
  delayMicroseconds(2);
  digitalWrite(trigPinf,HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPinf,LOW);

  ticktockf = pulseIn(echoPinf,HIGH); //in one cm there are 29 microseconds.
  gapf = ticktockf*0.0344/2;

  return gapf;
}

//take in the distance of the left wall
float rightdist()
{
  float gapr;
  float ticktockr;

  digitalWrite(trigPinr,LOW);
  delayMicroseconds(2);
  digitalWrite(trigPinr,HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPinr,LOW);

  ticktockr = pulseIn(echoPinr,HIGH); //in one cm there are 29 microseconds.
  gapr = ticktockr*0.0344/2;

  return gapr;
}

//take in the distance of the front wall
float leftdist()
{
  float gapl;
  float ticktockl;

  digitalWrite(trigPinl,LOW);
  delayMicroseconds(2);
  digitalWrite(trigPinl,HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPinl,LOW);

  ticktockl = pulseIn(echoPinl,HIGH); //in one cm there are 29 microseconds.
  gapl = ticktockl*0.0344/2;

  return gapl;
}

//Reduces the path if it can be shortedned and dynamically midifies the path storing array.
void reduce(int dir[], int &pt)
{ 
  int i=pt;
  if(i>=2)
  {
    //RUL = U.. (or u turn instead of right turn, u turn then left turn
    if((dir[i-1]==3)&&(dir[i-2]==2)&&(dir[i]==1))
    {
      dir[i-2]=3;
      pt = pt -2;
    }
    //LUL = F..
    else if((dir[i-1]==3)&&(dir[i-2]==1)&&(dir[i]==1))
    {
      dir[i-2]=0;
      pt = pt -2;
    }
    //LUR = U..
    else if((dir[i-1]==3)&&(dir[i-2]==1)&&(dir[i]==2))
    {
     dir[i-2]=3;
     pt = pt -2; 
    }
    //FUF = U..
    else if((dir[i-1]==3)&&(dir[i-2]==0)&&(dir[i]==0))
    {
      dir[i-2]=3;
      pt = pt -2;
    }
    //FUL = R..
    else if((dir[i-1]==3)&&(dir[i-2]==0)&&(dir[i]==1))
    {
      dir[i-2]=2;
      pt = pt -2;
    }
    //LUF = R..
    else if((dir[i-1]==3)&&(dir[i-2]==1)&&(dir[i]==0))
    {
      dir[i-2]=2;
      pt = pt -2;
    }
    return;
  }
}

//Stops the car
void stopit()
{
  digitalWrite(9,LOW);
  digitalWrite(10,LOW);
  digitalWrite(11,LOW);
  digitalWrite(12,LOW);
}

//Move forward according to the shortest path when encountering a junction
void frontturn()
{
  for(int n=1;n<=8;n++)
  {gofront();delay((timefr)/8);}

  digitalWrite(9,LOW);
  digitalWrite(10,LOW);
  digitalWrite(11,LOW);
  digitalWrite(12,LOW);
  delay(1000);
}

//take a right turn according to the shortest path.
void rightturn()
{
  stopit();
  delay(1000);
  float prevfdist = frontdist();

  //while(abs(frontdist() - prevfdist)<=(prevfdist/2)-1)
  for(int n=1;n<=5;n++)
  {
    gofront();
    delay(260);
  }
  digitalWrite(9,HIGH);
  digitalWrite(10,LOW);
  digitalWrite(11,LOW);
  digitalWrite(12,HIGH);

  delay(t);
  //gofront();
  //delay(2400);
  float prevfrdist = frontdist();

  while(abs(frontdist()-prevfrdist)<=18)
  //for(int n=1;n<=10;n++)
  {
    gofront();
    delay(300);
  }
  digitalWrite(9,LOW);
  digitalWrite(10,LOW);
  digitalWrite(11,LOW);
  digitalWrite(12,LOW);
  delay(1000);
}

void setup()
{
  //ultrasonic sensors setup
  pinMode (trigPinf, OUTPUT);
  pinMode (echoPinf, INPUT);
  pinMode (trigPinr, OUTPUT);
  pinMode (echoPinr, INPUT);
  pinMode (trigPinl, OUTPUT);
  pinMode (echoPinl, INPUT);

  pinMode (9,OUTPUT);
  pinMode (10,OUTPUT);
  pinMode (11,OUTPUT);
  pinMode (12,OUTPUT);

  Serial.begin(9600);

  //dir[0] = 0;
}

void loop()
{
  if (nlr==7)
  {
    found=true;  //Reached the end
    for(int i=0;i<=2;i++){Serial.print(dir[i]);}
    i=-1;j=0;nlr=0;  //Back to start again

    //Stops the bot for 30 seconds after reaching to the end. 
    digitalWrite(9,LOW);
    digitalWrite(10,LOW);
    digitalWrite(11,LOW);
    digitalWrite(12,LOW);
    delay(30000);
  }

  //Front,right and left distances.
  float fdist;
  float rdist;
  float ldist;

  //Front, right, and left travel time in echoPin
  float fduration;
  float rduration;
  float lduration;

  //Arrays which stores the value of five durations...The robot will take only the median value(after sorting) with error bearing capacity of 40%
  float fdur[5]; 
  float rdur[5];
  float ldur[5];
  float ldista[5];

  //apply for front ultrasonic sensor
  for(int i=0;i<=4;i++)
  {
    digitalWrite(trigPinf,LOW);  //clearing the TrigPin
    delayMicroseconds(5);
    digitalWrite(trigPinf,HIGH); 
    delayMicroseconds(10);
    digitalWrite(trigPinf,LOW);

    fdur[i] = pulseIn(echoPinf, HIGH);  //returns the time for which the wave travelled
  }

  fduration = middleval(fdur);
  fdist = fduration*0.0344/2;    //distance of the wall in the forward direction

  //Apply for right ultrasonic sensor
  for(int i=0;i<=4;i++)
  {    
    digitalWrite(trigPinr,LOW); 
    delayMicroseconds(5);
    digitalWrite(trigPinr,HIGH); 
    delayMicroseconds(10);
    digitalWrite(trigPinr,LOW);

    rdur[i] = pulseIn(echoPinr, HIGH);
  }
  
  rduration = middleval(rdur);
  rdist = rduration*0.0344/2;    //distance of the wall on its right side.

  //Apply for left ultrasonic sensor
  for(int i=0;i<=4;i++)
  {    
    digitalWrite(trigPinl,LOW); 
    delayMicroseconds(5);
    digitalWrite(trigPinl,HIGH); 
    delayMicroseconds(10);
    digitalWrite(trigPinl,LOW);

    ldur[i] = pulseIn(echoPinl, HIGH);
  }
  
  lduration = middleval(ldur);
  ldist = lduration*0.0344/2;    //distance of the wall on its left side.

  if((fdist>=125)||(rdist>=150)||(ldist>=400)) {return;} //Cancelling out any error values...goest back to void loop().

//Setting up the booleans.
  fsensor = false;
  rsensor = false;
  lsensor = false;

  if(rdist<=righthold) rsensor = true;
  if(ldist<=lefthold) lsensor = true;
  if(fdist<=fronthold) fsensor = true;

  //Left wall following algorithm
  //If left is closed ...
  if((lsensor==true))
  {
    //apply a U-Turn
    if((rsensor==true)&&(fsensor==true))
    {
      j=j+1;
      i=i+1;
      dir[i]=3;
      reduce(dir,i);
      
      digitalWrite(9,HIGH);
      digitalWrite(10,LOW);
      digitalWrite(11,LOW);
      digitalWrite(12,LOW);
      delay(2*t);
    }

    //If Front is open
    else if(fsensor==false)
    {
      if((rsensor==false)&&(frontdist()>=40))       //IF both front and right are open
      {
        i = i+1;
        j = j+1;

        if((found==true)&(dir[i]!=0))  //After reaching the end...checks the sensor
        {
          rightturn();
          return;
        }
        else
        {
          if(found==false)
          {
            dir[i] = 0; //moving forward over right
            reduce(dir,i);
          }
          timefr = tfr + 65*nfor;
          nfor=nfor+1;
          
          stopit();
          delay(1000);
          
          for(int g=1;g<=10;g++){gofront();delay(timefr/10);}
          
          stopit();
          delay(1000);
        }
      }
      else{gofront();delay(300);} //Else moving forward only front is open.
    }
    //for a right turn
    else
    {
      i = i+1;
      j = j+1;
      dir[1] = 2;
      reduce(dir,i);

      float prevfdist = frontdist();

      while(abs(frontdist()-prevfdist)<=(prevfdist/2)-2)
      {
        gofront();
        delay(300);
        if(frontdist()<=4.5)
        {break;}
      }
      digitalWrite(9,HIGH);
      digitalWrite(10,LOW);
      digitalWrite(11,LOW);
      digitalWrite(12,HIGH);
      delay(t);

      float prevfrdist = frontdist();

      while(abs(frontdist()-prevfrdist)<=15.2)
      {
        gofront();
        delay(300);
        if(frontdist()<=4.5)
        {break;}
      }
    }
  }
  else
  {
    //for a left turn
    i=i+1;
    j=j+1;

    if((found==true)&&(dir[i]!=1))
    {
      if((dir[i]==2)&&(rightdist>=10)){rightturn();return;}
      else if((dir[i]==0)&&(fsensor==false)){frontturn();return;}
    }
    else
    {
      dir[i]=1; //left turn
      nlr=nlr+1;
      reduce(dir,i);//calling reduce function to shorten the path dynamically..if path is not yet completed
      {gofront(); delay(tlbef);}
      digitalWrite(9,LOW); //take a left turn..
      digitalWrite(10,LOW);
      digitalWrite(11,HIGH);
      digitalWrite(12,LOW);
      delay(2*t);

      for(int n=1;n<=8;n++)
      {gofront();delay(tlaf/8);}

      stopit();
      delay(1000);
    }
  }

delay(320);
}
