#define fronthold 12  // Threshold value in front direction
#define righthold 20  // Threshold value in right direction
#define lefthold 20   // Threshold value in left direction

/*i = initial
 *I = indices
 *j = junctions
 *d = dynamic
 *f = front
 *r = right
 *t = time
 *l = left
 *a = after
 *b = before
 *o = over
 *u = u-turn
 */
 
const int t = 1050;  // Time alotted for taking 90 degress for 9V!
int itfr = 2750; // Initial Time for which it moves forward when it chooses forward over right 
int dtfr;        // Dynamically set time...for which it moves forward, when it chooses forward over right
int tfbel = 440; // Time for which it moves forward before taking left turn.
int tfal = 1150; // Time for which it moves forward after taking left turn.
int nfor = 0;    // Number of times it chooses straight over right
int nl = 0;      // Number of times it takes left turn.
bool found=false;// If its true, it indicates that the bot has reached the end
int dir[100];    // Array for storing the path of the bot.
int I=-1;        // For the indices of the dir array.
int j=0;         // Implies the number of junctions bot passed through

const int trigPinf = 2; //Front Ultrasonic Sensor
const int echoPinf = 3; 

const int trigPinr = 4; //Right Ultrasonic Sensor
const int echoPinr = 5;

const int trigPinl = 6; //Left Ultrasonic Sensor
const int echoPinl = 7;

//Booleans for recognising the walls. It will be True if the response sensor distance is less than the response threshold value.
bool fsensor;  //front Ultrasonic sensor
bool rsensor;  //right Ultrasonic sensor
bool lsensor;  //left Ultrasonic sensor

//sorts and returns the median value of a five element array.
float middleval(float arr[])
{
  for(int p=0;p<4;p++)
  {
    for(int q=0;q<4;q++)
    { 
      if(arr[q]>arr[q+1])
      {
        int temp = arr[q];
        arr[q] = arr[q+1];
        arr[q+1] = temp;
      }
    }
  }
 return arr[2]; // Median Value
}

void movefront()
{
  digitalWrite(10, HIGH);
  digitalWrite(11,LOW);
  digitalWrite(12,HIGH);
  digitalWrite(13,LOW);
}

//take in the distance of the front wall
float frontdist();
{
  float gapf;
  float ticktockf;

  digitalWrite(trigPinf,LOW);
  delayMicroseconds(2);
  digitalWrite(trigPinf,HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPinf,LOW);

  ticktockf = pulseIn(echoPinf,HIGH); //in one cm there are 29 microseconds.
  gapf = ticktockf*0.0344/2;

  return gapf;
}

//take in the distance of the left wall
float rightdist();
{
  float gapr;
  float ticktockr;

  digitalWrite(trigPinr,LOW);
  delayMicroseconds(2);
  digitalWrite(trigPinr,HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPinr,LOW);

  ticktockr = pulseIn(echoPinr,HIGH); //in one cm there are 29 microseconds.
  gapr = ticktockr*0.0344/2;

  return gapr;
}

//take in the distance of the front wall
float leftdist();
{
  float gapl;
  float ticktockl;

  digitalWrite(trigPinl,LOW);
  delayMicroseconds(2);
  digitalWrite(trigPinl,HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPinl,LOW);

  ticktockl = pulseIn(echoPinl,HIGH); //in one cm there are 29 microseconds.
  gapl = ticktockl*0.0344/2;

  return gapl;
}

//Reduces the path if it can be shortedned and dynamically midifies the path storing array.
void reduce(int dir[dir], int &pt)
{ 
  int i=pt;
  if(i>=2)
  {
    //RUL = U.. (or u turn instead of right turn, u turn then left turn
    if((dir[i-1]==3)&&(dir[i-2]==1)&&(dir[i]==1))
    {
      dir[i-2]=0;
      pt = pt -2;
    }
    //LUL = F..
    else if((dir[i-1]==3)&&(dir[i-2]==1)&&(dir[i]==2))
    {
      dir[i-2]=3;
      pt = pt -2;
    }
    //LUR = U..
    else if((dir[i-1]==3)&&(dir[i-2]==0)&&(dir[i]==2))
    {
     dir[i-2]=3;
     pt = pt -2; 
    }
    //FUF = U..
    else if((dir[i-1]==3)&&(dir[i-2]==0)&&(dir[i]==1))
    {
      dir[i-2]=3;
      pt = pt -2;
    }
    //FUL = R..
    else if((dir[i-1]==3)&&(dir[i-2]==0)&&(dir[i]==1))
    {
      dir[i-2]=2;
      pt = pt -2;
    }
    //LUF = R..
    else if((dir[i-1]==3)&&(dir[i-2]==1)&&(dir[i]==0)
    {
      dir[i-2]=2;
      pt = pt -2;
    }
    return;
  }
}

//Stops the car
void stopit()
{
  digitalWrite(10,LOW);
  digitalWrite(11,LOW);
  digitalWrite(12,LOW);
  digitalWrite(13,LOW);
}

//Move forward according to the shortest path when encountering a junction
void frontturn()
{
  for(int n=1;n<=8;n++)
  {gofront();delay((dtfr)/8);}

  digitalWrite(10,LOW);
  digitalWrite(11,LOW);
  digitalWrite(12,LOW);
  digitalWrite(13,LOW);
  delay(1000);
}

/take a right turn according to the shortest path.
void rightturn()
{
  stopit()
  delay(1000);
  float prevfdist = frontdist();

  //while(abs(frontdist() - prevfdist)<=(prevfdist/2)-1)
  for(int n=1;n<=5;n++)
  {
    gofront();
    delay(260);
  }
  digitalWrite(10,HIGH);
  digitalWrite(11,LOW);
  digitalWrite(12,LOW);
  digitalWrite(13,HIGH);

  delay(t);
  //gofront();
  //delay(2400);
  float prevfrdist = frontdist();

  while(abs(frontdist()-prevfrdist)<=18)
  //for(int n=1;n<=10;n++)
  {
    gofront();
    delay(300);
  }
  digitalWrite(10,LOW);
  digitalWrite(11,LOW);
  digitalWrite(12,LOW);
  digitalWrite(13,LOW);
  delay(1000);
}
