#define fronthold 12  // Threshold value in front direction
#define righthold 20  // Threshold value in right direction
#define lefthold 20   // Threshold value in left direction

/*i = initial
 *I = indices
 *j = junctions
 *d = dynamic
 *f = front
 *r = right
 *t = time
 *l = left
 *a = after
 *b = before
 *o = over
 *u = u-turn
 */
 
const int t = 1050;  // Time alotted for taking 90 degress for 9V!
int itfr = 2750; // Initial Time for which it moves forward when it chooses forward over right 
int dtfr;        // Dynamically set time...for which it moves forward, when it chooses forward over right
int tfbel = 440; // Time for which it moves forward before taking left turn.
int tfal = 1150; // Time for which it moves forward after taking left turn.
int nfor = 0;    // Number of times it chooses straight over right
int nl = 0;      // Number of times it takes left turn.
bool found=false;// If its true, it indicates that the bot has reached the end
int dir[100];    // Array for storing the path of the bot.
int I=-1;        // For the indices of the dir array.
int j=0;         // Implies the number of junctions bot passed through

const int trigPinf = 2; //Front Ultrasonic Sensor
const int echoPinf = 3; 

const int trigPinr = 4; //Right Ultrasonic Sensor
const int echoPinr = 5;

const int trigPinl = 6; //Left Ultrasonic Sensor
const int echoPinl = 7;

//Booleans for recognising the walls. It will be True if the response sensor distance is less than the response threshold value.
bool fsensor;  //front Ultrasonic sensor
bool rsensor;  //right Ultrasonic sensor
bool lsensor;  //left Ultrasonic sensor

//sorts and returns the median value of a five element array.
float middleval(float arr[])
{
  for(int p=0;p<4;p++)
  {
    for(int q=0;q<4;q++)
    { 
      if(arr[q]>arr[q+1])
      {
        int temp = arr[q];
        arr[q] = arr[q+1];
        arr[q+1] = temp;
      }
    }
  }
 return arr[2]; // Median Value
}

void movefront()
{
  digitalWrite(10, HIGH);
  digitalWrite(11,LOW);
  digitalWrite(12,HIGH);
  digitalWrite(13,LOW);
}

//take in the distance of the front wall
float frontdist();
{
  float gapf;
  float ticktockf;

  digitalWrite(trigPinf,LOW);
  delayMicroseconds(2);
  digitalWrite(trigPinf,HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPinf,LOW);

  ticktockf = pulseIn(echoPinf,HIGH); //in one cm there are 29 microseconds.
  gapf = ticktockf*0.0344/2;

  return gapf;
}

//take in the distance of the left wall
float rightdist();
{
  float gapr;
  float ticktockr;

  digitalWrite(trigPinr,LOW);
  delayMicroseconds(2);
  digitalWrite(trigPinr,HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPinr,LOW);

  ticktockr = pulseIn(echoPinr,HIGH); //in one cm there are 29 microseconds.
  gapr = ticktockr*0.0344/2;

  return gapr;
}

//take in the distance of the front wall
float leftdist();
{
  float gapl;
  float ticktockl;

  digitalWrite(trigPinl,LOW);
  delayMicroseconds(2);
  digitalWrite(trigPinl,HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPinl,LOW);

  ticktockl = pulseIn(echoPinl,HIGH); //in one cm there are 29 microseconds.
  gapl = ticktockl*0.0344/2;

  return gapl;
}

//Reduces the path if it can be shortedned and dynamically midifies the path storing array.
void reduce(int dir[dir], int &pt)
{ 
  int i=pt;
  if(i>=2)
  {
    //RUL = U.. (or u turn instead of right turn, u turn then left turn
    if((dir[i-1]==3)&&(dir[i-2]==1)&&(dir[i]==1))
    {
      dir[i-2]=0;
      pt = pt -2;
    }
    //LUL = F..
    else if((dir[i-1]==3)&&(dir[i-2]==1)&&(dir[i]==2))
    {
      dir[i-2]=3;
      pt = pt -2;
    }
    //LUR = U..
    else if((dir[i-1]==3)&&(dir[i-2]==0)&&(dir[i]==2))
    {
     dir[i-2]=3;
     pt = pt -2; 
    }
    //FUF = U..
    else if((dir[i-1]==3)&&(dir[i-2]==0)&&(dir[i]==1))
    {
      dir[i-2]=3;
      pt = pt -2;
    }
    //FUL = R..
    else if((dir[i-1]==3)&&(dir[i-2]==0)&&(dir[i]==1))
    {
      dir[i-2]=2;
      pt = pt -2;
    }
    //LUF = R..
    else if((dir[i-1]==3)&&(dir[i-2]==1)&&(dir[i]==0)
    {
      dir[i-2]=2;
      pt = pt -2;
    }
    return;
  }
}

//Stops the car
void stopit()
{
  digitalWrite(10,LOW);
  digitalWrite(11,LOW);
  digitalWrite(12,LOW);
  digitalWrite(13,LOW);
}

//Move forward according to the shortest path when encountering a junction
void frontturn()
{
  for(int n=1;n<=8;n++)
  {gofront();delay((dtfr)/8);}

  digitalWrite(10,LOW);
  digitalWrite(11,LOW);
  digitalWrite(12,LOW);
  digitalWrite(13,LOW);
  delay(1000);
}

/take a right turn according to the shortest path.
void rightturn()
{
  stopit()
  delay(1000);
  float prevfdist = frontdist();

  //while(abs(frontdist() - prevfdist)<=(prevfdist/2)-1)
  for(int n=1;n<=5;n++)
  {
    gofront();
    delay(260);
  }
  digitalWrite(10,HIGH);
  digitalWrite(11,LOW);
  digitalWrite(12,LOW);
  digitalWrite(13,HIGH);

  delay(t);
  //gofront();
  //delay(2400);
  float prevfrdist = frontdist();

  while(abs(frontdist()-prevfrdist)<=18)
  //for(int n=1;n<=10;n++)
  {
    gofront();
    delay(300);
  }
  digitalWrite(10,LOW);
  digitalWrite(11,LOW);
  digitalWrite(12,LOW);
  digitalWrite(13,LOW);
  delay(1000);
}

void setup()
{
  //ultrasonic sensors setup
  pinMode (trigPinf, OUTPUT);
  pinMode (echoPinf, INPUT);
  pinMode (trigPinr, OUTPUT);
  pinMode (echoPinr, INPUT);
  pinMode (trigPinl, OUTPUT);
  pinMode (echoPinl, INPUT);

  pinMode (9,OUTPUT);
  pinMode (10,OUTPUT);
  pinMode (11,OUTPUT);
  pinMode (12,OUTPUT);

  Serial.begin(9600);

  //dir[0] = 0;
}

void loop()
{
  if (nlr==7)
  {
    found=true;  //Reached the end
    for(int i=0;i<=2;i++){Serial.print(dir[i]);}
    i=-1;j=0;nlr=0;  //Back to start again

    //Stops the bot for 30 seconds after reaching to the end. 
    digitalWrite(9,LOW);
    digitalWrite(10,LOW);
    digitalWrite(11,LOW);
    digitalWrite(12,LOW);
    delay(30000);
  }

  //Front,right and left distances.
  float fdist;
  float rdist;
  float ldist;

  //Front, right, and left travel time in echoPin
  float fduration;
  float rduration;
  float lduration;

  //Arrays which stores the value of five durations...The robot will take only the median value(after sorting) with error bearing capacity of 40%
  float fdur[5]; 
  float rdur[5];
  float ldur[5];
  float ldista[5];

  //apply for front ultrasonic sensor
  for(int i=0;i<=4;i++)
  {
    digitalWrite(trigPinf,LOW);  //clearing the TrigPin
    delayMicroseconds(5);
    digitalWrite(trigPinf,HIGH); 
    delayMicroseconds(10);
    digitalWrite(trigPinf,LOW);

    fdur[i] = pulseIn(echoPinf, HIGH);  //returns the time for which the wave travelled
  }

  fduration = middleval(fdur);
  fdist = fduration*0.0344/2;    //distance of the wall in the forward direction

  //Apply for right ultrasonic sensor
  for(int i=0;i<=4;i++)
  {    
    digitalWrite(trigPinr,LOW); 
    delayMicroseconds(5);
    digitalWrite(trigPinr,HIGH); 
    delayMicroseconds(10);
    digitalWrite(trigPinr,LOW);

    rdur[i] = pulseIn(echoPinr, HIGH);
  }
  
  rduration = middleval(rdur);
  rdist = rduration*0.0344/2;    //distance of the wall on its right side.

  //Apply for left ultrasonic sensor
  for(int i=0;i<=4;i++)
  {    
    digitalWrite(trigPinl,LOW); 
    delayMicroseconds(5);
    digitalWrite(trigPinl,HIGH); 
    delayMicroseconds(10);
    digitalWrite(trigPinl,LOW);

    ldur[i] = pulseIn(echoPinl, HIGH);
  }
  
  lduration = middleval(ldur);
  ldist = lduration*0.0344/2;    //distance of the wall on its left side.

  if((fdist>=125)||(rdist>=150)||(ldist>=400)) {return;} //Cancelling out any error values...goest back to void loop().

//Setting up the booleans.
  fsensor = false;
  rsensor = false;
  lsensor = false;

  if(rdist<=righthold) rsensor = true;
  if(ldist<=lefthold) lsensor = true;
  if(fdist<=fronthold) fsensor = true;
}
